\chapter{Getting started}
This chapter will cover some of the most basic things that you need to 
understand in order to write some very simple SSL/TLS code. Let's start off with
a ``Hello World'' client. It's purpose is simply to open up an SSL/TLS
connection to a remote server, send a simple message, and then close the
connection. Don't worry if you don't understand all of the individual steps yet,
we will cover them in the rest of this chapter. See Listing
\ref{lst:hello-world-client}.

\lstinputlisting[float=p,label=lst:hello-world-client,lastline=55,
caption=A simple ``Hello World'' client]
{devel-tls/get-start/simpleclient.c}

\section{Library Initialisation}

Let's walk through this code sample step-by-step. Firstly we initialise 
``libssl''. OpenSSL provides two libraries ``libcrypto'' and ``libssl''. The 
former provides all of the underlying cryptography capabilities that are 
required, as well as other ``helper'' functions. The latter adds onto that an
understanding of how to communicate using the SSL/TLS protocol. Before you can 
use libssl you must first initialise it. This initialisation step will take all 
of the necessary steps to initialise the underlying libcrypto library. However 
it only initialises ``enough'' for libssl use. Therefore if you want to 
additionally use libcrypto capabilities directly then you will need to 
explicitly initialise that too.

There are two steps to libssl initialisation. The first of these is to call 
\verb!SSL_load_error_strings()!. There are numerous errors that may occur 
during libssl usage. Some examples of errors that could occur are:
\begin{itemize}
\item A remote peer sends an illegal message.
\item It is not possible to find a ciphersuite that is acceptable to both 
parties.
\item It is not possible to find a common protocol version. 
\item The remote peer unexpectedly closed the connection.
\item Some internal error (bug) was hit.
\end{itemize}

OpenSSL maintains an internal table of all the errors that could occur along 
with their human readable description, as well as the internal function and 
line number within the library that issued the error. This information is very 
helpful for tracking down problems. For this reason calling 
\verb!SSL_load_error_strings()! is strongly recommended before using 
libssl. The disadvantage is that loading this table of data does consume some 
memory. This could be a problem in some environments (e.g. embedded systems), 
and therefore in certain circumstances you may be appropriate to not load the
error strings. If you choose to omit this step though, be prepared for later 
difficulties in the event that errors occur.

The second step in initialisation is to call \verb!SSL_library_init()!. 
This performs a number of initialisation steps including preparing the required 
ciphers and digests for use. Calling this function is mandatory prior to 
calling other libssl functions. You may encounter references to two other 
functions in some sources:
\begin{itemize}
\item\verb!OpenSSL_add_ssl_algorithms()!; and 
\item\verb!SSLeay_add_ssl_algorithms()!.
\end{itemize}
These two functions are actually  synonyms for \verb!SSL_library_init()! but are
present for backwards compatibility reasons only, i.e. don't use them in new
code.

\section{Creating an \texttt{SSL\_CTX}}

In order to create an SSL/TLS connection you must first create an
\verb!SSL_CTX! object. A single \verb!SSL_CTX! can be shared across
many SSL/TLS connections. It provides a mechanism for setting up configuration
that is common to a set of connections. Creating an \verb!SSL_CTX! is 
simply a matter of calling the function \verb!SSL_CTX_new!. That function 
takes an \verb!SSL_METHOD! as a parameter. For clients there are five 
primary \verb!SSL_METHOD!s that could be used:
\begin{itemize}
\item \verb!SSLv3_client_method()! Connections based on this method are 
\emph{only} capable of using SSLv3.0.
\item \verb!TLSv1_client_method()! Creates connections that can 
\emph{only} use TLS v1.0.
\item \verb!TLSv1_1_client_method()! Creates connections that can 
\emph{only} use TLS v1.1.
\item \verb!TLSv1_2_client_method()! Creates connections that can 
\emph{only} use TLS v1.2.
\item \verb!TLS_client_method()! Creates connections that can negotiate 
the highest available protocol version.
\end{itemize}

You may see references to \verb!SSLv23_client_method()!. This is the old 
name for \verb!TLS_client_method()! and is synonymous with it. New code 
should use the new name. Don't be confused by the old name - 
\verb!SSLv23_client_method()! is capable of negotiating \emph{all} 
supported protocol versions.

Normally you only ever need to use \verb!TLS_client_method()!. Don't use 
the other protocol specific methods unless you really need to. If you want to 
be able to restrict which protocol versions can be negotiated (for example to 
prevent SSLv3 from being used) then there are a set of options to allow this 
(see table \ref{tab:protocol-opts}).

\begin{table}[tb]
\centering
\begin{tabular}{|l|l|}
\hline
\rowcolor{LightGray}
Option Name & Option Description \\
\hline
\verb!SSL_OP_NO_SSLv3! & Disable SSL v3 support \\
\hline
\verb!SSL_OP_NO_TLSv1! & Disable TLS v1.0 support \\
\hline
\verb!SSL_OP_NO_TLSv1_1! & Disable TLS v1.1 support \\
\hline
\verb!SSL_OP_NO_TLSv1_2! & Disable TLS v1.2 support \\
\hline
\end{tabular}
\caption{Protocol negotiation options}
\label{tab:protocol-opts}
\end{table}

To apply these options you use the \verb!SSL_CTX_set_options()! command. You 
can also set them on individual \verb!SSL! objects if you wish to have that 
level of control using \verb!SSL_set_options()!. You must do so \emph{before} 
any connection is established in order for them to have an effect. You can 
``OR'' multiple options together if you want to disable multiple options in one 
go. For example the following code disables both SSL v3 and TLS v1.0:
\begin{lstlisting}
SSL_CTX_set_options(SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);
\end{lstlisting}

You should only have a single contiguous range of enabled protocol versions, 
e.g. do not disable SSL v3 and TLS v1.1, whilst keeping TLS v1.0 and TLS v1.2 
enabled.

In our simple client code in listing \ref{lst:hello-world-client} we are not
disabling any protocol versions so we simply call \verb!SSL_CTX_new()! with
\verb!TLS_client_method()!. The \verb!SSL_CTX_new! function will return a
\verb!NULL! result if something went wrong, so it is important that you check
the return value.

In our example code we are also specifying an additional setting for our
\verb!SSL_CTX! through a call to \verb!SSL_CTX_set_verify()!. This defines the 
behaviour we want for verifying any digital certificates that servers might
present to us. This function actually provides us with the capability to define 
a very fine degree of control over that verification process. It takes three 
arguments:
\begin{enumerate}
\item a pointer to the \texttt!SSL\_CTX! that we are working with;
\item a verification mode that we wish to apply to the \texttt!SSL\_CTX!; and
\item an optional callback function.
\end{enumerate}

For clients the verification mode that you almost always want to set is 
\verb!SSL_VERIFY_PEER!. This causes OpenSSL to verify the certificate that the 
server presents to us, and abort the connection if that verification fails. You
should \emph{always} set this for clients unless you really know what you are 
doing.

In our example we are not going to use the callback function, so we just set 
that to \verb!NULL!.

\section {Connecting to a server}

